{% load static %}

<!DOCTYPE html>
<html lang="en">
<head>
    <title>My amazing App</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>


<link rel="stylesheet" type="text/css" href="{% static 'MyApp/assets/MyApp_index.css' %}">

<body>

<div style="width: 30%;">
    <h1>The input area</h1>
    <textarea >Zone de texte!</textarea>

</div>

<div style="width: 70%;">
    <h1>The display area</h1>

    <div id="graph-container"></div>



    <svg height="0" width="0">
        <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto">
            <path d="M0,0 L0,10 L10,5 z" fill="black" />
        </marker>
    </svg>


    <script>
        //var graphData =
        // Use D3.js to render the directed graph using graphData
        // Example D3.js code for rendering a directed graph goes here



        // Sample graph data (you can replace this with data from your Django view)
        const graphData = {{ graph_data|safe }};

        // Define the dimensions of the graph container
        const width = 960;
        const height = 600;


        // Create an SVG element to render the graph
        const svg = d3.select("#graph-container")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        // Create a D3 force simulation to layout the graph
        var simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(function(d) { return d.id; }))
            .force('charge', d3.forceManyBody()
                .strength(-1900)
                .theta(0.5)
                .distanceMax(1500)
            )
            .force('collision', d3.forceCollide().radius(function(d) {
                return d.radius
            }))
            .force("center", d3.forceCenter(document.querySelector("#graph-container").clientWidth / 2, document.querySelector("#graph-container").clientHeight / 2));

        var defs = svg.append("defs");
        defs.append("radialGradient")
            .attr("id", "source-gradient")
            .selectAll("stop")
            .data([
                {offset: "20%", color: "#eda515"},
                {offset: "100%", color: "#827777"},
            ])
            .enter().append("stop")
            .attr("offset", function(d) { return d.offset; })
            .attr("stop-color", function(d) { return d.color; });

        // Add links and nodes to the simulation
        // const link = svg.append("g")
        //     .selectAll("line")
        //     .data(graphData.links)
        //     .enter()
        //     .append("line")
        //     .style("stroke", "black")  // Set the color of the links
        //     .style("stroke-width", 2) // Set the width of the links;
        //     .attr("marker-end", "url(#arrow)");


        const link = svg.append("g")
            .selectAll("line")
            .data(graphData.links)
            .enter()
            .append('line')
            .attr('x1', d => d.source.x)
            .attr('x2', d => d.target.x)
            .attr('y1', d => d.source.y)
            .attr('y2', d => d.target.y)
            .style("stroke", "black")  // Set the color of the links
            .style("stroke-width", 2) // Set the width of the links;
            .attr("marker-end", "url(#arrow)");

        const node = svg.append("g")
            .selectAll("circle")
            .data(graphData.nodes)
            .enter()
            .append("circle")
            .attr("r", 35)
            .style("fill", "url(#source-gradient)" )
            .style("opacity", 0.5)
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        var label = svg.append("g")
            .attr("class", "labels")
            .selectAll("text")
            .data(graphData.nodes)
            .enter().append("text")
            .text(function(d) { return d.name; })
            .attr("class", "label");

        label
            .style("text-anchor", "middle")
            .style("font-size", "10px");

        // Define the tick function to update node and link positions
        simulation.nodes(graphData.nodes)
            .on("tick", ticked);

        simulation.force("link")
            .links(graphData.links);

        // Tick function to update node and link positions
        function ticked() {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);

            label
                .attr("x", function(d) { return d.x; })
                .attr("y", function (d) { return d.y; });
        }

        // Functions for drag behavior
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    </script>



</div>




</body>
</html>